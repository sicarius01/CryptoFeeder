# 검증 및 테스트 방안 (Validation & Testing Strategy)

## 1. 결과물 검증 방법

* **코드 리뷰**: `clippy -- -D warnings`를 통해 모든 경고를 에러로 처리하여 코드 품질을 확보합니다. 특히 `unsafe` 코드 블록 사용을 최소화하고, 동시성 관련 로직을 신중하게 검토합니다.
* **로그 분석**: 실행 중 출력되는 로그를 통해 연결/재연결 시퀀스, 구독 요청/응답, 오류 메시지가 예상대로 동작하는지 확인합니다.
* **패킷 스니핑 및 디코딩**:
    * **1단계 (캡처)**: `tcpdump`나 `Wireshark`를 사용하여 멀티캐스트 그룹으로 전송되는 UDP 패킷을 실시간으로 캡처합니다.
    * **2단계 (검증)**: 캡처된 패킷의 바이너리 데이터가 **`udp_packet.md`**와 **`event_packet.md`** 명세와 100% 일치하는지 헥스 에디터(Hex Editor)를 통해 직접 확인합니다.
    * **3단계 (자동화)**: 수신된 패킷을 자동으로 파싱하여 내용을 사람이 읽을 수 있는 형태로 출력하는 **간단한 Rust 기반 디코더 유틸리티**를 함께 작성합니다. 이는 가장 확실한 검증 수단입니다.

## 2. 테스트 전략

* **유닛 테스트 (Unit Tests)**:
    * 순수 함수(Pure functions)에 대해 집중적으로 작성합니다.
    * 예: 특정 거래소의 JSON 페이로드 샘플을 입력했을 때, 원하는 내부 구조체로 정확히 파싱되는지 검증. 패킷 직렬화/역직렬화 함수의 정확성 검증.
* **통합 테스트 (Integration Tests)**:
    * 실제 거래소(테스트넷이 있다면 우선 사용)에 연결하여 전체 파이프라인이 동작하는지 검증합니다.
    * WebSocket 수신 -> 파싱 -> 직렬화 -> UDP 전송 -> 디코더 유틸리티로 수신 및 확인까지의 E2E(End-to-End) 흐름을 테스트합니다.
* **스트레스 테스트 (Stress Tests)**:
    * 네트워크 연결을 의도적으로 반복해서 끊고 연결하며 재연결 로직의 안정성과 리소스 누수 여부를 확인합니다.
    * 데이터가 폭증하는 상황을 가정하여 CPU 및 메모리 사용량이 안정적으로 유지되는지 모니터링합니다.